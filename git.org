* 基本概念
** 三种状态
   对于任何一个文件，在 git 内都只有三种状态:已提交(committed)，已修改(modified)，
   已暂存(staged).已提交表示该文件已经被安全地保存在本地数据库中;已修改表示修改
   了某个文件，但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存的清
   单中。
** git 的工作流程:
   1)在工作目录中修改某些文件
   2)对这些修改的了的文件作快照，并保存到暂存区域
   3)提交更新，将保存在暂存区域的文件快照转储到 git 目录中。
** 配置文件
   /etc/gitconfig
   对所有用户都使用的配置，使用 git config 时加上 --system 参数可修改此文件.
   ~/.gitconfig
   当前用户的配置文件，使用 git config 时加上 --global 参数可修改此文件.
   .git/config
   当前工作目录下的配置文件，只对此项目有用.
* 基本配置
** 全局配置
   配置的信息可在 ~/.git/config 中找到.

   $ git config --global user.name "用户名"
   $ git config --global user.email "用户邮箱"
   前两个是必需的，下面的是可选的.
   $ git config --global core.editor 你喜欢的编辑器
   默认的编辑器是 vi/vim.
   $ git config --global merge.tool 差异分析工具
   可使用 vimdiff、kdiff3、tkdiff、meld、xxdiff、emerge、gvimdiff、ecmerge、
   opendiff 等合并工具。
   $ git config --list
   查看配置信息.
   $ git config 配置信息名
   可查看某个具体的配置信息，如
   $ git config user.name
** 局部配置
   在当前的工程下:

   $ git config user.name "用户名"
   $ git config user.email "用户邮箱"
   
   可在当前工程的 .git/config 目录下找到这些配置信息.
* 获取帮助
  $ git help 命令
  $ git 命令 --help
  $ man git-命令
* 向 github.com 推送
  现在 github.com 上建立一个 repository,然后在 git 项目的当前文件夹下
  $ git remote add origin git@github.com:username/建立的仓库名.git
  $ git push origin master
  以后每次推送该项目时，只需
  $ git push origin master
* 从 github.com 取回
  在项目目录下 
  $ git pull origin master
* 建立自己的仓库
  $ git init
  这是初次建立仓库时要做的。
  $ git add 文件
  $ git commit -m "描述信息"
  以上是建立仓库的一般方法。
  若用
  $ git commit
  则会调用配置中设定的编辑器来添加信息。
  若使用 git commit 时加上参数 -a ，则 git 会自动把所有已经跟踪过的文件暂存起来
  一并提交，从而跳过 git add 步骤。
  git add 后可接要跟踪的文件或目录的路径，若是目录的话，就说明要递归跟踪所有该目
  录下的文件。
  git add 命令根据目标文件的状态不同，它的效果也不同：可以用它开始跟踪新文件，或
  把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。
* 从仓库克隆
  git 收取的是项目历史的所有数据(每个文件的每个版本)，服务器上有的数据克隆后本地
  也都有了。如
  $ git clone git://github.com/schacon/grit.git
  默认的目录名是克隆的目录名，也可自己指定，如
  $ git clone git://github.com/schacon/grit.git 新的目录名
* 记录每次更新到仓库
  工作目录下的所有文件都不外乎两种状态：已跟踪或未跟踪。
  已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作
  一段时间后，它们的状态可能是未更新，已修改或已被放入暂存区。
  而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区
  域。
  初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。
* 检查当前文件状态
  $ git status
  最好在每次提交前用这个命令来检查下当前项目中的文件状态，然后再 commit.
* 忽略某些文件
  通过在当前项目的根目录下建立 .gitignore 文件来忽略某些不需纳入 git 管理的文件，
  如某些自动生成的临时文件等。要养成一开始设置好 .gitignore 文件的习惯，以免将来
  误提交无用的文件。
  该文件的编辑规范:
  1)所有空行或以 # 开头的行都会被 git 忽略
  2)可使用标准的 glob 模式匹配
  3)匹配模式最后跟反斜杠(/)说明要忽略的是目录
  4)要忽略指定模式以外的文件或目录，可在模式前加上 ! 取反
  glob 模式指 shell 所使用的简化了的正则表达式，如
  1) * 匹配零个或任意多个任意字符
  2) [abc] 匹配任何一个在放括号中的字符
  3) ? 只匹配一个任意字符
  4) [0-9] 表示匹配在某个范围内的字符或数值
  有几个例子要记住:
  /TODO          仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
  build/         忽略 build/ 目录下的所有文件
  doc/*.txt      忽略 doc 第一级子目录下的以 .txt 结尾的文件，但不忽略第二级等子
                 目录下的文件.
* 删除文件
** 从跟踪目录中删除且删除磁盘上的该文件
   $ git rm 文件
   若先在磁盘上删除了该文件，则再执行该命令也可。再次提交后就不会再跟踪管理该文
   件。
   若删除之前修改过且已经放到暂存区中，则必须要加 -f 参数，以防误删除文件后丢失
   修改的内容。
** 仅从跟踪目录中删除但不删除磁盘上的文件
   $ git rm --cached 文件
   若想在 git 命令中使用正则表达式，则要用如 \* 的形式，因为 git 有自己的文件模
   式扩展匹配。这样做后，可把这些文件置于仓库根目录下的 .gitignore 文件中。
* 移动文件
  如下两种形式等同:
  
  $ git mv README.txt README
  
  或

  $ mv README.txt README
  $ git rm README.txt
  $ git add README
* 查看提交历史
  $ git log
  还可加些参数，常用的有:
  -p 展开显示每次提交的内容差异
  -num 仅显示最近 num 次的更新
  在做代码审查或要快速浏览其他协作者提交的更新都做了哪些改动时，可使用以上两个选
  项。
  --stat 仅显示简要的增改行数统计
  --pretty=[oneline|short|full|fuller|format] 指定使用特殊的方式显示提交历史
  其中的 format 可定制要显示的记录格式，这样的输出便于后期编程提取分析，如
  $ git log --pretty=format:"%h - %an, %ar : %s"
  具体的使用方法可参考手册:
  $ git help log
  其中会有两个概念可能会混淆：作者(author)和提交者(committer). *作者* 指的是实际
  作出修改的人， *提交者* 指的是最后将此工作成果提交到仓库的人。
* 查看提交历史的图形化工具
  gitk
* 撤销操作
** 修改最后一次提交
   $ git commit --amend
   这相当于是对上次 commit 的补充，还是同一个提交。
   可以这样形象理解:就像把物品打包，后来发现少装了一个东西，再把缺少的东西装到该
   包中，最终还是同一个包裹。
** 取消已暂存的文件
   如在
   $ git add 文件
   后，发现现在不想暂存已经 add 的文件，那么可以通过
   $ git reset HEAD 暂时不想暂存的文件
   来使该文件恢复到未暂存的状态。
   可在 
   $ git status
   时看到对该命令的提示。
** 取消对文件的修改
   有时修改完文件后想要取消对它的修改，在使用 
   $ git status
   时会有提示操作，通过如下命令来取消上次对文件的修改
   $ git checkout -- 文件
   这样，该文件又处于未修改时的状态。
* 远程仓库
** 查看当前的远程库 
   在从网络上 clone 下的仓库下输入
   $ git remote
   时，至少可以看到一个名为 origin 的远程库，git 默认使用这个名字来标识你所
   clone 的原始仓库。
   $ git remote -v
   可看到对应的 clone 地址。若有多个远程仓库，此命令将全部列出。
** 添加远程仓库
   语法
   $ git remote add [shortname] [url]
   例 
   $ git remote add pb git://github.com/paulboone/ticgit.git
   这样就可以用 pb 来指代对应的仓库地址了。
   想获取 pb 中有的但本地仓库中没有的，可使用 
   $ git fetch pb
** 从远程仓库抓取数据
   $ git fetch [remote-name]
   该命令会到远程仓库中拉取所有你本地仓库中还没有的数据。但 fetch 命令只是将远端
   的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手
   工合并。

   $ git pull [remote-name]
   该命令会自动抓取数据，然后合并。
** 推送数据到远程仓库
   语法
   $ git push [remote-name] [branch-name]
   如
   $ git push origin master
   (Note: clone 操作会自动使用默认的 master 和 origin 名字).
   只有在所 clone 的服务器上有写权限，或同一时刻没有其他人在推数据，这条命令才会
   如期完成任务。若在你推送前，已有其他人推送了若干更新，那你的推送操作就会被驳
   回。必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。
** 查看远程仓库信息
   语法
   $ git remote show [remote-name]
   可用来查看某个远程仓库的详细信息.
** 远程仓库的删除和重命名
   重命名远程仓库的语法
   $ git remote rename [old-name] [new-name]
   对远程仓库的重命名，会使对应的分支名称发生变化。
   删除某个远程仓库
   $ git remote rm 仓库名
** 查看某个 remote 的详细内容
   $ git remote show 名称
* 打标签
** 标签种类
   git 使用的标签有两种类型： *轻量级的(lightweight)* 和 *含附注的(annotated)*
   *轻量级标签* 就像是个不会变化的分支，实际上就是个指向特定提交对象的引用。而 
   *含附注的标签* 实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含
   着标签名字、email 和日期，及标签说明，标签本身也允许使用 GPG 来签署或认证。
** 列出所有标签
   $ git tag
   显示的标签按字母顺序排列。
   如下的操作可显示部分感兴趣标签
   $ git tag -l 'v1.7.9.*'
** 含附注的标签
   如下例
   $ git tag -a v1.0 -m '这是附加信息'
** 查看相应标签
   如下例
   $ git show v1.0
** 签署标签
   若有自己的私钥，还可用 GPG 来签署标签，如下例:
   $ git tag -s v1.0 -m '这是附加信息'
** 验证标签
   可用来验证已经签署的标签，它会调用 GPG 来验证签名，故需要有签署者的公钥存放在
   keyring 中才能验证。
   如下例
   $ git tag -v 1.0
** 轻量级标签
   它实际上就是一个保存着对应提交对象的校验和信息的文件。如下例
   $ git tag v1.0
** 后期加注标签
   可在后期对早先的某次提交加注标签。如下例
   $ git tag -a v1.0 某次提交的前几位hash值
** 提交到远程仓库
   默认情况下， git push 并不会把标签传送到远端服务器，只有通过显式命令才能分享
   标签到远端仓库。如下例
   $ git push origin v1.0
   若要一次推送本地所有新增的标签，用下面的命令
   $ git push origin --tags
   之后，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。
* 自动补全
  使用时类似 Bash 的 Tab 自动补全和提示命令。
  把 git 源码下的 contrib/completion/ 下的 git-completion.bash 文件复制为
  ~/.git-completion.bash ，然后在 ~/.bashrc 下添加如下语句

  source ~/.git-completion.bash

  就可以使用了。
* 分支
** 创建分支
   $ git branch 分支名
   注意，创建后 git 并没有转到分支中，而是仍在当前的分支中。
** 分支跳转
   $ git checkout 分支名
** 创建并跳转到新的分支
   $ git checkout -b 分支名
   这个命令相当于是对前两个命令的合并。
** 合并分支
   常在 master 分支中合并其它分支，如名为 testing 的分支。先转到 master 分支下，
   然后执行
   $ git merge testing
** 删除分支
   当某个分支被合并后，如名为 testing 的分支，删除该分支用如下命令
   $ git branch -d testing
   这种方法只能删除已经合并过的分支，未合并的分支不能用这种方法删除，要用如下方
   法:
   $ git branch -D testing
** 冲突的合并
   在 git merge 时可能会出现有冲突的文件。任何包含未解决冲突的文件都会以未合并
   (unmerged) 状态列出。git 会在有冲突的文件里加入标准的冲突解决标记，可通过它们
   来手动定位并解决这些冲突。
   解决冲突的办法无非是二者选其一或由你亲自整合到一起。
   在解决了所有文件里的所有冲突后，运行 git add 将它们标记为 *已解决(resolved)*。
   因为一旦暂存，就表示冲突已经解决。
   
   可通过如下命令使用图形化的工具
   $ git mergetool
** 查看所有分支
   $ git branch
   星号所在行表示当前所在分支
   
   $ git branch -v
   可查看各个分支最后一次 commit 信息
   
   $ git branch --merged
   查看已经被并入到当前分支的分支
   
   $ git branch --no-merged
   查看当前尚未合并的分支
** 本地分支重命名
   重命名当前分支:
   $ git branch -m 新名字

   重命名任意分支:
   $ git branch -m 分支旧名称 分支新名称 

   Ref:
   +
     [[http://stackoverflow.com/questions/6591213/how-to-rename-local-branch][How to rename local branch?]]
** 远程分支重命名
   Ref:
   +
     [[http://stackoverflow.com/questions/1526794/rename-master-branch-for-both-local-and-remote-git-repositories][Rename master branch for both local and remote Git repositories]]
** pull 不在本地的远程分支
   $ git fetch origin  # 把远程仓库所有分支全部拉下来
   $ git checkout -b 新分支名  origin/目标分支名 
   
   Ref:
   + [[http://stackoverflow.com/questions/16473805/git-pull-origin-branch-overwrites-master][Git pull origin <branch> overwrites master?]]
   + [[http://stackoverflow.com/questions/1072261/push-and-pull-branches-in-git][Push and Pull Branches In Git]]
* 链接
  git 简易指南
  http://rogerdudler.github.com/git-guide/index.zh.html
  why git is bettern than X
  http://zh-cn.whygitisbetterthanx.com/#git-is-fast
* 打包
  以下操作都是在 git 项目下进行

  打包成 gzip :
  $ git archive master --prefix='project/' | gzip > project.tar.gz

  打包成 zip:
  $ git archive master --prefix='project/' --format=zip > project.zip

  打包成 tar:
  $ git archive master --prefix='project/' --format=tar > project.tar

* 常用操作
  只查看与某个文件相关的 commit:
  $ git log --follow 文件

  查看做了哪些改动:
  $ git whatchanged 
  $ git whatchanged --summary

  显示 git 管理的文件:
  $ git ls-files

  查看所有的别名:
  $ git config --get-regexp alias
* BEST PRACTICE
** 初始化工程前
   先建立好 README、.gitignore 文件后再 *git init* ，这样可以免去一些不必要的操
   作，如处理那些不想要 git 管理的文件.
** 管理 web 项目
*** 变更生效
	只有在 commit 后变更才能生效.
* git-svn
** Can't locate SVN/Core.pm
   使用 git svn 时，可能会提示这种错误，是因为缺少 libsvn-perl。按照 LFS 官网上
   安装 subversion 的帮助文档来安装，可以解决这个问题。
   我是通过重新编译 subversion 源码来解决的，具体的参考
   http://www.linuxfromscratch.org/blfs/view/svn/general/subversion.html
   以下是简要的介绍(以下操作是在解压后的目录中进行, $ 表示普通用户下进行, # 表示
   root 用户下进行):
  + 若要在 Apache-2.4.1 中使用 mod_dav_svn.so，需要修改下 subversion 的源码:
	
	$ sed -i 's#save_errno#aprerr#' subversion/mod_dav_svn/util.c
	
	(Apache-2.2 不需做这种修改)
  + 接着输入 
	
	$ ./configure --prefix=/usr --disable-static && make
	$ make swig-pl && make swig-py
	
	编译 swig-pl 是解决问题的关键。
  + (Optional)检测
	
	$ make check-swig-pl && make check-swig-py
	
  + 接着
	
	# make install && install -v -m755 -d /usr/share/doc/subversion-1.7.2/ && 
    cp -v -R doc/* /usr/share/doc/subversion-1.7.2/
	(注意其中的版本号因系统而异，根据自己当前系统的目录名来改)
	# make install-swig-pl && make install-swig-py
** git 和 svn 的主要区别
   svn 是一种集中式的版本控制工具，即用 svn 作为版本控制时，必须有个中心服务器，
   所有同一项目必须提交到服务器指定的目录下，在没连接到中心服务器时，不能做提交。
   而 git 是一种分布式的版本控制工具，即可在本地用 git 做版本控制，随时提交到本地，
   而且只要安装好 git 即可以使用。也可以把内容提交到服务器端，如很受欢迎的
   github.com 网站。有了 git,可以随时做版本控制，在能够连接到服务器时，再把内容提
   交到服务器上。
   两个简单的对比:
   http://www.aqee.net/5-fundamental-differences-between-git-svn/
   http://hi.baidu.com/yuhongchun027/blog/item/442c467e9ec335350cd7daf5.html
** git 和 svn 迁移的主要思路
   用 svn 作为版本控制的主体，最终所有的代码都提交到 svn 服务器上。git-svn 工具作
   为连接 svn 和 git 的桥梁。每个人都可以在本地的目录中使用 git 做版本控制工具，
   只有在和 svn 服务器进行交互时才使用 git-svn 工具。
** 基本流程
   如在 svn 服务器上有个名为 test 的项目，那么现在本地建立个名为 test 的目录，转
   到 test 目录下，输入
   $ git svn init svn服务器上test项目地址
   以本地 svn 服务器为例
   $ git svn init svn://127.0.0.1/test
   
   取出 svn 服务器上 test 项目某个版本的文件,如取出所有 Version3 的文件
   $ git svn fetch -r3
   
   与 svn 服务器端同步,用
   $ git svn rebase
   
   在本地使用 git 的命令做版本控制，在 git commit 后，把所有的内容提交到 svn 服务
   器端，使用
   $ git svn dcommit
   
   参考:
   http://flavio.castelli.name/howto_use_git_with_svn
** svn 常用用法
   启动 svn 服务器:
   # svnserve -d -r svn根目录地址
   
   将文件 checkout 到本地目录，例
   $ svn co svn://127.0.0.1/project
   
   添加新文件,例
   $ svn add test.c
   
   将改动提交到版本库
   $ svn commit -m "add test.c" test.c
   
   更新
   $ svn update               # 更新到最新的版本
* 搭建 git 服务器
  参见 
  http://www.rosoo.net/a/201102/10956.html
  http://blog.csdn.net/wirror800/article/details/5189564
* 清除之前的操作
  $ git reset --hard
* 撤销操作 
** 只在 "工作区" 进行了修改，但没有提交到 "暂存区" (即没进行 add 操作)
   法一:
   手动进行修改，撤销之前的操作.
   
   法二:
   通过如下命令进行撤销:
   $ git checkout -- 文件名
** 提交到了 "暂存区", 但没有进行 commit 操作
   先通过如下命令将操作从 "暂存区" 去除:
   $ git reset HEAD 文件名
   然后用上述中的两种操作形式进行.
** 进行了 commit 操作
   通过如下的形式进行回退:
   $ git reset --hard commit_id
** 参考
   + [[http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000][撤销修改]]
* HEAD
  git 用 *HEAD* 表示最新版本，上一个版本是 *HEAD^* (或 HEAD~1)，上上一个版本是
  *HEAD^^* (或 HEAD~2).
  更严谨的解释是，*HEAD* 指当前指向的 commit，若当前指向的不是最新的 commit，则
  被称为 *detached HEAD*.

  Ref:
  + [[http://stackoverflow.com/questions/2304087/what-is-head-in-git][What is HEAD in Git?]]
  + [[http://stackoverflow.com/questions/964876/head-and-orig-head-in-git/967611][HEAD and ORIG_HEAD in Git]]
* 查看历史命令
  $ git reflog
* 有用的别名
  $ git config --global alias.lg "log --color --graph
  --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold
  blue)<%an>%Creset' --abbrev-commit"
* 我的 workflow
  每个分支一次只处理一件事情.
  
  分支策略:
  + master
    与远程主 repo 保持一致.
  + dev
    本地开发分支.
    在本地没有 feature/bugfix 分支后，删除该分支，然后与 master 保持一致. 
  + feature-*
    从 master 分支出来，开发新的功能.
    该 feature 测试通过后，提 pull request 到远程 repo 中，然后合并到 dev 分支中.
    在远程 repo 接受该 feature 的 pull request 后，再删除该分支.
  + bugfix-*
    从 master 分支出来，修复 bug.
	该 bugfix 测试通过后，提 pull request 到远程 repo 中，然后合并到 dev 分支中. 
	在远程 repo 接受该 bugfix 的 pull request 后，再删除该分支.
* fetch 和 pull 的区别
  pull 相当于 fetch + merge.
* git pull 后恢复到上次的状态
  git pull 做了两个操作: git fetch 和 git merge。所以，需要回退的操作是 git
  merge.
  先通过下面的命令找到想要回退的状态:
  $ git reflog
  然后通过如下命令进行回退:
  $ git reset --hard 目标状态
* 显示所有 alias
  $ git config --get-regexp alias
* 开启 two-factor authentication 后命令行无密码访问项目
  先在 [[https://github.com/settings/applications][github applications]] 中申请一个 application 的 token，然后修改项目的
  .git/config 文件中 url 部分，改为如下类似下述形式:

  url = https://GITHUB用户名:申请的TOKEN@github.com/flyer103/Notes
* 不同 commit 间的 diff
  展示当前 commit 和上个 commit 之间的 diff:
  $ git diff COMMIT^ COMMIT

  展示当前 commit 和下个 commit 之间的 diff:
  $ git diff COMMIT^!
* 查看某个文件的变更
  $ git log -p 文件名
* 只查看某个文件的历史
  $ git log -p 文件名

  Ref:
  + [[View the change history of a file using Git versioning][http://stackoverflow.com/questions/278192/view-the-change-history-of-a-file-using-git-versioning]]
